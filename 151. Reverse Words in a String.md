## Initial Solution
1.  Use `left` and `right` pointers to locate the word from the tail to the head of the string.
2.  Use `temp` pointer to traverse through the located word, append to the result string `res`.

```cpp
class Solution {
public:
    string reverseWords(string s) {
        string res="";
        int right = s.size()-1, left, temp;
        while (s[right] == ' ')
            right--;
        while(right >= 0){
            left = right;
            while (left >=0 && s[left] != ' ')
                left--;
            temp = left+1;
            while (temp <= right)   
                res+=s[temp++];
            res+=' ';
            right = left;
            while (right >=0 && s[right] == ' ') 
                right--;
        }
        res.pop_back();
        return res;
    }
};
```

## Note 
- We can use the in-place algorithm to reduce the space complexity:
  1. Remove the redundant spaces.
  2. Reverse the whole string.
  3. Reverse each word.
 
## Second Solution
1. Use two pointers `slow` and `fast` to remove the redundant spaces. `slow` point to the location to replaced.
2. Resize the string.
3. Reverse the whole string.
4. Reverse each word.
```cpp
class Solution {
public:
    string reverseWords(string s) {
         // remove redundant spaces
        int slow=0, fast=0;
        while (fast < s.size()){                        
            while(fast < s.size() && s[fast] == ' ')    // skip space
                fast++;
            while (fast < s.size() && s[fast] != ' ')
                s[slow++] = s[fast++];
            // s[fast] == ' '
            if (fast < s.size() && slow < s.size())
                s[slow++] = ' ';
        }

        // remove spaces on end of the string
        if (s[slow-1] == ' ')
            s.resize(slow-1);
        else 
            s.resize(slow);

        // reverse the string
        int left = 0, right = s.size()-1;
        while (left < right)
            swap(s[left++],s[right--]);

        // reverse the words
        int head=0, tail;
        while (head < s.size()){
            for (tail = head; tail < s.size() && s[tail] != ' '; tail++);   // find the boundary
            for (left = head, right = tail-1; left < right; swap(s[left++],s[right--]));
            head = ++tail;
        }
        return s;
    }
};
```
